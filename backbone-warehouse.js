// Generated by CoffeeScript 1.4.0
/*

  *** Warehouse ***

  The Warehouse class provides easier access to Backbone's collections and models.

  A "store" refers to either a model or a collection. Stores are referenced by name, and maintain
  a state. Although it includes a minimal promise spec, specifying a promise wrapper function will
  wrap all results in the corresponding promise.

  Properties
  • stores       : object containing collections and models

  Public methods
  • add          : adds instances of data stores
  • get          : returns a single store
  • fetch        : fetches a list of data stores (alias: data)
  • isFetched    : returns whether all specified stores have been fetched (alias: fetched)
  • fetchAndLoad : fetches data (like fetch) and modules (like require)

  Private methods
  • keyEvent     : returns the type of event we should listen for
  • fetchOne     : fetches a single data store
*/

var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty;

(function() {
  var Warehouse, freeExports, freeGlobal, freeModule, freeWindow, moduleExports, objectTypes, root, wrap, _P;
  Warehouse = Warehouse = (function() {
    /*
    
          constructor
    
          • [Object]   stores  : keys should be store names and values the store
          • [Function] wrapper : a promise-wrapper (optional)
    */

    function Warehouse(stores, wrapper) {
      this.fetchOne = __bind(this.fetchOne, this);
      if (wrapper != null) {
        Warehouse.prototype.wrap = wrapper;
      }
      this.stores = {};
      this.add(stores || {});
      return;
    }

    /*
    
          function add
    
          Adds instances of data stores.
    
          [Object] stores : keys should be store names and values the store
    */


    Warehouse.prototype.add = function(stores) {
      var name, store;
      for (name in stores) {
        if (!__hasProp.call(stores, name)) continue;
        store = stores[name];
        this.stores[name] = {
          store: store,
          state: "new"
        };
      }
    };

    /*
    
          function get
    
          Returns a single store (does not check if fetched).
    
          <String> name : the key of the desired data store
    */


    Warehouse.prototype.get = function(name) {
      return this.stores[name].store;
    };

    /*
    
          function keyEvent
    
          Returns the type of event we should listen for.
    
          <Store> store : which store to analyze (can optionally be a string)
    */


    Warehouse.prototype.keyEvent = function(store) {
      if ("string" === typeof store) {
        store = this.stores[store];
      }
      if (store.store instanceof Backbone.Collection) {
        return "reset";
      } else {
        return "sync";
      }
    };

    /*
    
          function fetch (alias: data)
    
          Fetches stores, and returns a promise containing array stores.
    
          <String>  names : names of stores, separated by spaces
          <Boolean> force : whether to force a refresh of the stores
    */


    Warehouse.prototype.fetch = function(names, force) {
      var name, promises;
      if (names == null) {
        names = "";
      }
      if (force == null) {
        force = false;
      }
      if (names === "") {
        return Warehouse.prototype.wrap(_P.resolve({}));
      }
      if ("string" === typeof names) {
        names = names.trim().split(/\s+/);
      }
      promises = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          _results.push(this.fetchOne(name, force));
        }
        return _results;
      }).call(this);
      return Warehouse.prototype.wrap(_P.all(promises).then(function(arr) {
        var i, obj, _i, _len;
        obj = {};
        for (i = _i = 0, _len = names.length; _i < _len; i = ++_i) {
          name = names[i];
          obj[name] = arr[i];
        }
        return _P.resolve(obj);
      }));
    };

    Warehouse.prototype.data = function(names, force) {
      if (names == null) {
        names = "";
      }
      if (force == null) {
        force = false;
      }
      return this.fetch(names, force);
    };

    /*
    
          function fetchOne
    
          Fetches a single data store and returns a promises containing said store.
    
          <String>   name  : name of store
          <Boolean>  force : whether to force a refresh of the store
    */


    Warehouse.prototype.fetchOne = function(name, force, done) {
      var ev, fetchOne, store,
        _this = this;
      if (force == null) {
        force = false;
      }
      store = this.stores[name];
      ev = this.keyEvent(store);
      fetchOne = function() {
        store.state = "fetching";
        return Warehouse.prototype.wrap(new _P(function(resolve, reject) {
          store.store.once(ev, function() {
            store.state = "fetched";
            return resolve(store.store);
          });
          return store.store.fetch({
            reset: true,
            error: reject
          });
        }));
      };
      switch (store.state) {
        case "new":
          return fetchOne();
        case "fetched":
          if (force) {
            return fetchOne();
          } else {
            return Warehouse.prototype.wrap(_P.resolve(store.store));
          }
          break;
        case "fetching":
          return Warehouse.prototype.wrap(new _P(function(resolve, reject) {
            return store.store.once(ev, function() {
              if (!force) {
                return resolve(store.store);
              }
              store.state = "fetched";
              return _this.fetchOne(name, true);
            });
          }));
      }
    };

    /*
    
          function isFetched (alias: fetched)
    
          Returns whether all specified stores have been fetched.
    
          <String>  names : names of desired stores, separated by spaces
    */


    Warehouse.prototype.isFetched = function(names) {
      var fetched, name, _i, _len;
      if (names == null) {
        names = "";
      }
      if ("string" === typeof names) {
        names = names.trim().split(/\s+/);
      }
      fetched = true;
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        if (this.stores[name].state !== "fetched") {
          fetched = false;
          break;
        }
      }
      return fetched;
    };

    Warehouse.prototype.fetched = function(names) {
      if (names == null) {
        names = "";
      }
      return this.isFetched(names);
    };

    /*
    
          function fetchAndLoad
    
          Incorporates both data and requirejs-based loading.
    */


    Warehouse.prototype.fetchAndLoad = function(data, modules, done) {
      var promises;
      if (data == null) {
        data = "";
      }
      if (modules == null) {
        modules = [];
      }
      done = done || function() {};
      promises = [this.fetch(data)];
      if (!(modules != null) || !modules.length) {
        promises.push(_P.resolve([]));
      } else {
        if (!(typeof requirejs !== "undefined" && requirejs !== null)) {
          throw new Error("RequireJS is needed but missing");
        }
        promises.push(new _P(function(resolve, reject) {
          return requirejs(modules, function() {
            return resolve([].slice.call(arguments, 0));
          });
        }));
      }
      return Warehouse.prototype.wrap(_P.all(promises).then(function(args) {
        return done.apply(null, [args[0]].concat(args[1]));
      }));
    };

    /*
    
          function fetchAll
    
          Fetches all collections
    */


    Warehouse.prototype.fetchAll = function(force) {
      var key, names, val, _ref;
      if (force == null) {
        force = false;
      }
      names = [];
      _ref = this.stores || {};
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        val = _ref[key];
        names.push(key);
      }
      return this.fetch(names);
    };

    return Warehouse;

  })();
  /*
  
      Promiz (and wrappers)
  
      Very compact promise library. Promiz.js Copyright (c) 2014 Zolmeister: https://github.com/Zolmeister/promiz
      Updated to use Promiz with no global by removing module.exports and globals at end
  */

  !function(){function a(a){global.setImmediate?setImmediate(a):global.importScripts?setTimeout(a):(c++,d[c]=a,global.postMessage(c,"*"))}function b(c){function d(a,b,c,d){if("object"!=typeof j&&"function"!=typeof j||"function"!=typeof a)d();else try{var e=0;a.call(j,function(a){e++||(j=a,b())},function(a){e++||(j=a,c())})}catch(f){j=f,c()}}function e(){var a;try{a=j&&j.then}catch(b){return j=b,i=2,e()}d(a,function(){i=1,e()},function(){i=2,e()},function(){try{1==i&&"function"==typeof f?j=f(j):2==i&&"function"==typeof g&&(j=g(j),i=1)}catch(b){return j=b,l()}j==h?(j=TypeError(),l()):d(a,function(){l(3)},l,function(){l(1==i&&3)})})}if("function"!=typeof c&&void 0!=c)throw TypeError();var f,g,h=this,i=0,j=0,k=[];h.promise=h,h.resolve=function(b){return f=this.fn,g=this.er,i||(j=b,i=1,a(e)),this},h.reject=function(b){return f=this.fn,g=this.er,i||(j=b,i=2,a(e)),this},h.then=function(a,c){var d=new b;return d.fn=a,d.er=c,3==i?d.resolve(j):4==i?d.reject(j):k.push(d),d},h["catch"]=function(a){return h.then(null,a)};var l=function(a){i=a||4,k.map(function(a){3==i&&a.resolve(j)||a.reject(j)})};try{"function"==typeof c&&c(h.resolve,h.reject)}catch(m){h.reject(m)}return h}global=this;var c=1,d={},e=!1;global.setImmediate||global.addEventListener("message",function(b){if(b.source==global)if(e)a(d[b.data]);else{e=!0;try{d[b.data]()}catch(b){}delete d[b.data],e=!1}}),b.resolve=function(a){if(1!=this._d)throw TypeError();return new b(function(b){b(a)})},b.reject=function(a){if(1!=this._d)throw TypeError();return new b(function(b,c){c(a)})},b.all=function(a){function c(b,e){if(e)return d.resolve(e);if(b)return d.reject(b);var f=a.reduce(function(a,b){return b&&b.then?a+1:a},0);0==f&&d.resolve(a),a.map(function(b,d){b&&b.then&&b.then(function(b){return a[d]=b,c(),b},c)})}if(1!=this._d)throw TypeError();if(!(a instanceof Array))return b.reject(TypeError());var d=new b;return c(),d},b.race=function(a){function c(b,e){if(e)return d.resolve(e);if(b)return d.reject(b);var f=a.reduce(function(a,b){return b&&b.then?a+1:a},0);0==f&&d.resolve(a),a.map(function(a){a&&a.then&&a.then(function(a){c(null,a)},c)})}if(1!=this._d)throw TypeError();if(!(a instanceof Array))return b.reject(TypeError());if(0==a.length)return new b;var d=new b;return c(),d},b._d=1,Promiz=b}();;

  _P = Promiz;
  wrap = function(x) {};
  Warehouse.prototype.wrap = function(x) {
    return x;
  };
  /*
  
      Module-loading code (as used in Lo-dash)
  */

  objectTypes = {
    "function": true,
    object: true
  };
  freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
  freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
  freeGlobal = freeExports && freeModule && typeof global === "object" && global;
  freeWindow = objectTypes[typeof window] && window;
  moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
  /*
  
      Used as a reference to the global object.
  
      The `this` value is used if it is the global object to avoid Greasemonkey's
      restricted `window` object, otherwise the `window` object is used.
  */

  root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || this;
  if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
    return define("Warehouse", function() {
      return Warehouse;
    });
  } else if (freeExports && freeModule) {
    if (moduleExports) {
      return (freeModule.exports = Warehouse).Warehouse = Warehouse;
    } else {
      return freeExports.Warehouse = Warehouse;
    }
  } else {
    return root.Warehouse = Warehouse;
  }
})();
