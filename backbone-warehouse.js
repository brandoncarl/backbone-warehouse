// Generated by CoffeeScript 1.4.0
/*

  *** Warehouse ***

  (c) 2015 Brandon Carl, Aventura Labs

  The Warehouse class provides easier access to Backbone's collections and models.

  A "store" refers to either a model or a collection. Stores are referenced by name, and maintain
  a state. Although it includes a minimal promise spec, specifying a promise wrapper function will
  wrap all results in the corresponding promise.

  Properties
  • stores       : object containing collections and models

  Public methods
  • add          : adds instances of data stores
  • get          : returns a single store
  • fetch        : fetches a list of data stores (alias: data)
  • fetchAll     : fetches all data stores
  • isFetched    : returns whether all specified stores have been fetched (alias: fetched)
  • fetchAndLoad : fetches data (like fetch) and modules (like require)

  Private methods
  • keyEvent     : returns the type of event we should listen for
  • fetchOne     : fetches a single data store
*/

var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty;

(function() {
  var Warehouse, all, freeExports, freeGlobal, freeModule, freeWindow, isFn, isUndef, moduleExports, objectTypes, root, __all, __promise;
  __promise = null;
  __all = null;
  isFn = function(x) {
    return typeof x === "function";
  };
  isUndef = function(x) {
    return typeof x === "undefined";
  };
  all = function(tasks, done) {
    var i, n, onComplete, onProgress, results, task, _i, _len, _results;
    n = tasks.length;
    results = {};
    onComplete = function() {
      var data, i, _i, _ref;
      data = [];
      for (i = _i = 0, _ref = tasks.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        data.push(results[i]);
      }
      return done(null, data);
    };
    onProgress = function(pos) {
      return function(err, single) {
        if (err) {
          return done(err);
        }
        results[pos] = single;
        if (--n === 0) {
          return onComplete();
        }
      };
    };
    _results = [];
    for (i = _i = 0, _len = tasks.length; _i < _len; i = ++_i) {
      task = tasks[i];
      _results.push(task(onProgress(i)));
    }
    return _results;
  };
  Warehouse = Warehouse = (function() {
    /*
    
          constructor
    
          • [Object] stores  : keys should be store names and values the store
          • [Object] plib    : a promise-wrapper (optional) { promise, all }
    */

    function Warehouse(stores, plib) {
      this.fetchOne = __bind(this.fetchOne, this);
      if (plib != null) {
        __promise = plib.promise;
        __all = plib.all;
      }
      this.stores = {};
      this.add(stores || {});
      return;
    }

    /*
    
          function add
    
          Adds instances of data stores.
    
          [Object] stores : keys should be store names and values the store
    */


    Warehouse.prototype.add = function(stores) {
      var name, store;
      for (name in stores) {
        if (!__hasProp.call(stores, name)) continue;
        store = stores[name];
        this.stores[name] = {
          store: store,
          state: "new"
        };
      }
    };

    /*
    
          function get
    
          Returns a single store (does not check if fetched).
    
          <String> name : the key of the desired data store
    */


    Warehouse.prototype.get = function(name) {
      return this.stores[name].store;
    };

    /*
    
          function keyEvent
    
          Returns the type of event we should listen for.
    
          <Store> store : which store to analyze (can optionally be a string)
    */


    Warehouse.prototype.keyEvent = function(store) {
      if ("string" === typeof store) {
        store = this.stores[store];
      }
      if (store.store instanceof Backbone.Collection) {
        return "reset";
      } else {
        return "sync";
      }
    };

    /*
    
          function fetch (alias: data)
    
          Fetches stores, and returns a promise resolving to an object containing the stores by name.
    
          <String>   names  : names of stores, separated by spaces
          <Boolean>  force  : whether to force a refresh of the stores
          <Function> [done] : optional callback (err, data)
    */


    Warehouse.prototype.fetch = function(names, force, done) {
      var fetchOne, fn, iterator;
      if (names == null) {
        names = "";
      }
      if (force == null) {
        force = false;
      }
      if (isFn(force)) {
        done = force;
        force = false;
      }
      fetchOne = this.fetchOne;
      iterator = function(name) {
        return (function(callback) {
          return fetchOne(name, force, callback);
        });
      };
      fn = function(cb) {
        var name, tasks;
        if (names === "") {
          return cb(null, {});
        }
        if ("string" === typeof names) {
          names = names.trim().split(/\s+/);
        }
        tasks = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = names.length; _i < _len; _i++) {
            name = names[_i];
            _results.push(iterator(name));
          }
          return _results;
        })();
        return all(tasks, function(err, data) {
          var i, obj, _i, _len;
          if (err) {
            return cb(err, {});
          }
          obj = {};
          for (i = _i = 0, _len = names.length; _i < _len; i = ++_i) {
            name = names[i];
            obj[name] = data[i];
          }
          return cb(null, obj);
        });
      };
      if (isUndef(done) && __promise) {
        return __promise(function(resolve, reject) {
          fn(function(err, data) {
            if (err) {
              return reject(err);
            } else {
              return resolve(data);
            }
          });
        });
      } else {
        return fn(done || function() {});
      }
    };

    Warehouse.prototype.data = function(names, force) {
      if (names == null) {
        names = "";
      }
      if (force == null) {
        force = false;
      }
      return this.fetch(names, force);
    };

    /*
    
          function fetchOne
    
          Fetches a single data store and returns a promises containing said store.
    
          <String>   name  : name of store
          <Boolean>  force : whether to force a refresh of the store
          <Function> [done] : optional callback (err, data)
    */


    Warehouse.prototype.fetchOne = function(name, force, done) {
      var fn,
        _this = this;
      if (force == null) {
        force = false;
      }
      if (isFn(force)) {
        done = force;
        force = false;
      }
      fn = function(cb) {
        var ev, fetchOne, store;
        store = _this.stores[name];
        ev = _this.keyEvent(store);
        fetchOne = function() {
          store.state = "fetching";
          store.store.once(ev, function() {
            store.state = "fetched";
            return cb(null, store.store);
          });
          return store.store.fetch({
            reset: true,
            error: cb
          });
        };
        switch (store.state) {
          case "new":
            return fetchOne();
          case "fetched":
            if (force) {
              return fetchOne();
            } else {
              return cb(null, store.store);
            }
            break;
          case "fetching":
            return store.store.once(ev, function() {
              if (!force) {
                return cb(null, store.store);
              }
              store.state = "fetched";
              return _this.fetchOne(name, true, cb);
            });
        }
      };
      if (isUndef(done) && __promise) {
        return __promise(function(resolve, reject) {
          fn(function(err, data) {
            if (err) {
              return reject(err);
            } else {
              return resolve(data);
            }
          });
        });
      } else {
        return fn(done || function() {});
      }
    };

    /*
    
          function isFetched (alias: fetched)
    
          Returns whether all specified stores have been fetched.
    
          <String>  names : names of desired stores, separated by spaces
    */


    Warehouse.prototype.isFetched = function(names) {
      var fetched, name, _i, _len;
      if (names == null) {
        names = "";
      }
      if ("string" === typeof names) {
        names = names.trim().split(/\s+/);
      }
      fetched = true;
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        if (this.stores[name].state !== "fetched") {
          fetched = false;
          break;
        }
      }
      return fetched;
    };

    Warehouse.prototype.fetched = function(names) {
      if (names == null) {
        names = "";
      }
      return this.isFetched(names);
    };

    /*
    
          function fetchAndLoad
    
          Incorporates both data and requirejs-based loading.
    
          <Function> [done] : optional callback (err, args...)
    */


    Warehouse.prototype.fetchAndLoad = function(data, modules, done) {
      var fetcher, fn, loader, noop, tasks,
        _this = this;
      if (data == null) {
        data = "";
      }
      if (modules == null) {
        modules = [];
      }
      fetcher = function(callback) {
        return _this.fetch(data, callback);
      };
      tasks = [fetcher];
      if (!(modules != null) || !modules.length) {
        noop = function(callback) {
          return callback(null, []);
        };
        tasks.push(noop);
      } else {
        if (!(typeof requirejs !== "undefined" && requirejs !== null)) {
          throw new Error("RequireJS is needed but missing");
        }
        loader = function(callback) {
          return requirejs(modules, function() {
            return callback(null, [].slice.call(arguments, 0));
          });
        };
        tasks.push(loader);
      }
      fn = function(cb) {
        return all(tasks, function(err, args) {
          return cb.apply(null, [args[0]].concat(args[1]));
        });
      };
      if (isUndef(done) && __promise) {
        return __promise(function(resolve, reject) {
          all(tasks, function(err, args) {
            if (err) {
              return reject(err);
            } else {
              return resolve([args[0]].concat(args[1]));
            }
          });
        });
      } else {
        if (done == null) {
          done = function() {};
        }
        return all(tasks, function(err, args) {
          return done.apply(null, [null, args[0]].concat(args[1]));
        });
      }
    };

    /*
    
          function fetchAll
    
          Fetches all collections
    
          <Function> [done] : optional callback (err, data)
    */


    Warehouse.prototype.fetchAll = function(force, done) {
      var fn, key, names, val, _ref,
        _this = this;
      if (force == null) {
        force = false;
      }
      if (isFn(force)) {
        done = force;
        force = false;
      }
      names = [];
      _ref = this.stores || {};
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        val = _ref[key];
        names.push(key);
      }
      fn = function(cb) {
        return _this.fetch(names, force, cb);
      };
      if (isUndef(done) && __promise) {
        return __promise(function(resolve, reject) {
          fn(function(err, data) {
            if (err) {
              return reject(err);
            } else {
              return resolve(data);
            }
          });
        });
      } else {
        return fn(done || function() {});
      }
    };

    return Warehouse;

  })();
  /*
  
      Module-loading code (as used in Lo-dash)
  */

  objectTypes = {
    "function": true,
    object: true
  };
  freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
  freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
  freeGlobal = freeExports && freeModule && typeof global === "object" && global;
  freeWindow = objectTypes[typeof window] && window;
  moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
  /*
  
      Used as a reference to the global object.
  
      The `this` value is used if it is the global object to avoid Greasemonkey's
      restricted `window` object, otherwise the `window` object is used.
  */

  root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || this;
  if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
    return define("Warehouse", function() {
      return Warehouse;
    });
  } else if (freeExports && freeModule) {
    if (moduleExports) {
      return (freeModule.exports = Warehouse).Warehouse = Warehouse;
    } else {
      return freeExports.Warehouse = Warehouse;
    }
  } else {
    return root.Warehouse = Warehouse;
  }
})();
